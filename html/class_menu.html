<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ProjetoDA2: Menu Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ProjetoDA2
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_menu-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Menu Class Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a4d86919a8e5f249d8ff16d63de4edf3c" id="r_a4d86919a8e5f249d8ff16d63de4edf3c"><td class="memItemLeft" align="right" valign="top"><a id="a4d86919a8e5f249d8ff16d63de4edf3c" name="a4d86919a8e5f249d8ff16d63de4edf3c"></a>
static double&#160;</td><td class="memItemRight" valign="bottom"><b>Cristofides</b> (Graph&lt; int &gt; *g, vector&lt; int &gt; &amp;minPath)</td></tr>
<tr class="separator:a4d86919a8e5f249d8ff16d63de4edf3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46fbe8bb966c9fc7e4bd1da5df046841" id="r_a46fbe8bb966c9fc7e4bd1da5df046841"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_menu.html#a46fbe8bb966c9fc7e4bd1da5df046841">greedyHeuristica</a> (Graph&lt; int &gt; *g, vector&lt; int &gt; &amp;minPath)</td></tr>
<tr class="memdesc:a46fbe8bb966c9fc7e4bd1da5df046841"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a greedy heuristic algorithm to find an approximate solution. This function uses a greedy algorithm to approximate a solution for the TSP. It sorts all edges by weight and adds the smallest edge to the solution set, making sure there are no cycles and that the resulting path is valid.  <br /></td></tr>
<tr class="separator:a46fbe8bb966c9fc7e4bd1da5df046841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a597c1bf9031eccdeb0b9fd61de2430e6" id="r_a597c1bf9031eccdeb0b9fd61de2430e6"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_menu.html#a597c1bf9031eccdeb0b9fd61de2430e6">randomSwap</a> (Graph&lt; int &gt; *g, vector&lt; int &gt; &amp;minPath, double minDistance)</td></tr>
<tr class="memdesc:a597c1bf9031eccdeb0b9fd61de2430e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a random swap of two nodes in the path to possibly find a shorter path. This function tries to improve the path length by randomly swapping two nodes of the "minPath". It calculates the new total distance after the swap and updates the path if the new distance is shorter.  <br /></td></tr>
<tr class="separator:a597c1bf9031eccdeb0b9fd61de2430e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a966c7db5e08c724bbf39ca6ba9bdc1" id="r_a2a966c7db5e08c724bbf39ca6ba9bdc1"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_menu.html#a2a966c7db5e08c724bbf39ca6ba9bdc1">twoOpt</a> (Graph&lt; int &gt; *g, vector&lt; int &gt; &amp;path, double &amp;dist)</td></tr>
<tr class="memdesc:a2a966c7db5e08c724bbf39ca6ba9bdc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Improves the path using the 2-opt algorithm. This function applies the 2-opt algorithm to optimize the given path. It swaps pairs of edges to find a shorter path until there is no improvement possible.  <br /></td></tr>
<tr class="separator:a2a966c7db5e08c724bbf39ca6ba9bdc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11497665ca4442d4daa6737b22d8f1e9" id="r_a11497665ca4442d4daa6737b22d8f1e9"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_menu.html#a11497665ca4442d4daa6737b22d8f1e9">Backtracking</a> (Graph&lt; int &gt; &amp;graph, vector&lt; int &gt; &amp;minPath)</td></tr>
<tr class="memdesc:a11497665ca4442d4daa6737b22d8f1e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the shortest Hamiltonian cycle in the graph using backtracking. This function initializes the vertices and starts the backtracking from vertex 0, finding the shortest Hamiltonian cycle and updating the minimum path and distance.  <br /></td></tr>
<tr class="separator:a11497665ca4442d4daa6737b22d8f1e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a752da705cd22af35cb7f1b8b3ee3fcfb" id="r_a752da705cd22af35cb7f1b8b3ee3fcfb"><td class="memItemLeft" align="right" valign="top">static pair&lt; double, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_menu.html#a752da705cd22af35cb7f1b8b3ee3fcfb">nearestNeighborTSP</a> (Graph&lt; int &gt; *graph, vector&lt; int &gt; &amp;minPath, int inicialVertex)</td></tr>
<tr class="memdesc:a752da705cd22af35cb7f1b8b3ee3fcfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nearest neighbor heuristic. This function always visits the nearest unvisited vertex. It starts from a given initial vertex and returns to the initial vertex to complete the cycle.  <br /></td></tr>
<tr class="separator:a752da705cd22af35cb7f1b8b3ee3fcfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c56d16a93393d63d5a3b10f5dfebfae" id="r_a4c56d16a93393d63d5a3b10f5dfebfae"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_menu.html#a4c56d16a93393d63d5a3b10f5dfebfae">triangularApproximation</a> (Graph&lt; int &gt; *graph, vector&lt; int &gt; &amp;minPath)</td></tr>
<tr class="memdesc:a4c56d16a93393d63d5a3b10f5dfebfae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a triangular approximation of TSP using Prim's algorithm and depth-first search (DFS). This function build a minimum spanning tree (MST) of the graph using Prim's algorithm Then, computes an Eulerian circuit by performing a DFS on the MST starting from the first vertex. Finnaly, calculates the total distance of the path that visits each vertex exactly once.  <br /></td></tr>
<tr class="separator:a4c56d16a93393d63d5a3b10f5dfebfae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19645785398f3b4a29083574cff4adb5" id="r_a19645785398f3b4a29083574cff4adb5"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_menu.html#a19645785398f3b4a29083574cff4adb5">simulatedAnnealing</a> (Graph&lt; int &gt; *graph, vector&lt; int &gt; &amp;minPath)</td></tr>
<tr class="memdesc:a19645785398f3b4a29083574cff4adb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the Annealing algorithm to find an approximate solution for TSP. This function starts with an initial solution generated by the greedy heuristic. It then iteratively improves this solution by swapping two randomly selected vertices and checking if the new solution is better or if it should be accepted based on a probability function. The temperature gradually decreases, reducing the likelihood of accepting worse solutions over time.  <br /></td></tr>
<tr class="separator:a19645785398f3b4a29083574cff4adb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a11497665ca4442d4daa6737b22d8f1e9" name="a11497665ca4442d4daa6737b22d8f1e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11497665ca4442d4daa6737b22d8f1e9">&#9670;&#160;</a></span>Backtracking()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Menu::Backtracking </td>
          <td>(</td>
          <td class="paramtype">Graph&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>minPath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the shortest Hamiltonian cycle in the graph using backtracking. This function initializes the vertices and starts the backtracking from vertex 0, finding the shortest Hamiltonian cycle and updating the minimum path and distance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>Reference to the graph. </td></tr>
    <tr><td class="paramname">minPath</td><td>Reference to the vector with the minimum path.</td></tr>
  </table>
  </dd>
</dl>
<p>Complexity O(v^2 * 2^v), E: number of edges. </p><dl class="section return"><dt>Returns</dt><dd>The minimum distance of the Hamiltonian cycle. </dd></dl>

</div>
</div>
<a id="a46fbe8bb966c9fc7e4bd1da5df046841" name="a46fbe8bb966c9fc7e4bd1da5df046841"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46fbe8bb966c9fc7e4bd1da5df046841">&#9670;&#160;</a></span>greedyHeuristica()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Menu::greedyHeuristica </td>
          <td>(</td>
          <td class="paramtype">Graph&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>minPath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies a greedy heuristic algorithm to find an approximate solution. This function uses a greedy algorithm to approximate a solution for the TSP. It sorts all edges by weight and adds the smallest edge to the solution set, making sure there are no cycles and that the resulting path is valid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Pointer to the graph. </td></tr>
    <tr><td class="paramname">minPath</td><td>Vector to store the resulting path of vertices.</td></tr>
  </table>
  </dd>
</dl>
<p>Complexity O(V^2), V: number of vertices. </p><dl class="section return"><dt>Returns</dt><dd>The total weight of the edges in the solution. </dd></dl>

</div>
</div>
<a id="a752da705cd22af35cb7f1b8b3ee3fcfb" name="a752da705cd22af35cb7f1b8b3ee3fcfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a752da705cd22af35cb7f1b8b3ee3fcfb">&#9670;&#160;</a></span>nearestNeighborTSP()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; double, int &gt; Menu::nearestNeighborTSP </td>
          <td>(</td>
          <td class="paramtype">Graph&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>minPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>inicialVertex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Nearest neighbor heuristic. This function always visits the nearest unvisited vertex. It starts from a given initial vertex and returns to the initial vertex to complete the cycle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>Pointer to the graph. </td></tr>
    <tr><td class="paramname">minPath</td><td>Reference to the vector that will store the order of visited vertices in the path. </td></tr>
    <tr><td class="paramname">inicialVertex</td><td>The starting vertex for the TSP algorithm.</td></tr>
  </table>
  </dd>
</dl>
<p>Complexity O(E), E: number of edges. </p><dl class="section return"><dt>Returns</dt><dd>A pair containing the total weight of the TSP path and the number of vertices visited. </dd></dl>

</div>
</div>
<a id="a597c1bf9031eccdeb0b9fd61de2430e6" name="a597c1bf9031eccdeb0b9fd61de2430e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a597c1bf9031eccdeb0b9fd61de2430e6">&#9670;&#160;</a></span>randomSwap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Menu::randomSwap </td>
          <td>(</td>
          <td class="paramtype">Graph&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>minPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minDist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a random swap of two nodes in the path to possibly find a shorter path. This function tries to improve the path length by randomly swapping two nodes of the "minPath". It calculates the new total distance after the swap and updates the path if the new distance is shorter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Pointer to the graph. </td></tr>
    <tr><td class="paramname">minPath</td><td>Reference to the vector with the minimum path. </td></tr>
    <tr><td class="paramname">minDist</td><td>The minimum distance of the path.</td></tr>
  </table>
  </dd>
</dl>
<p>Complexity O(E), E: number of edges. </p><dl class="section return"><dt>Returns</dt><dd>The new minimum distance after performing the random swap. </dd></dl>

</div>
</div>
<a id="a19645785398f3b4a29083574cff4adb5" name="a19645785398f3b4a29083574cff4adb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19645785398f3b4a29083574cff4adb5">&#9670;&#160;</a></span>simulatedAnnealing()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Menu::simulatedAnnealing </td>
          <td>(</td>
          <td class="paramtype">Graph&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>minPath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs the Annealing algorithm to find an approximate solution for TSP. This function starts with an initial solution generated by the greedy heuristic. It then iteratively improves this solution by swapping two randomly selected vertices and checking if the new solution is better or if it should be accepted based on a probability function. The temperature gradually decreases, reducing the likelihood of accepting worse solutions over time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>Pointer to the graph. </td></tr>
    <tr><td class="paramname">minPath</td><td>Reference to a vector that will store the path.</td></tr>
  </table>
  </dd>
</dl>
<p>Complexity O(V^3), V: number of vertices. </p><dl class="section return"><dt>Returns</dt><dd>The total distance of the path. </dd></dl>

</div>
</div>
<a id="a4c56d16a93393d63d5a3b10f5dfebfae" name="a4c56d16a93393d63d5a3b10f5dfebfae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c56d16a93393d63d5a3b10f5dfebfae">&#9670;&#160;</a></span>triangularApproximation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Menu::triangularApproximation </td>
          <td>(</td>
          <td class="paramtype">Graph&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>minPath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes a triangular approximation of TSP using Prim's algorithm and depth-first search (DFS). This function build a minimum spanning tree (MST) of the graph using Prim's algorithm Then, computes an Eulerian circuit by performing a DFS on the MST starting from the first vertex. Finnaly, calculates the total distance of the path that visits each vertex exactly once. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Pointer to the graph. </td></tr>
    <tr><td class="paramname">minPath</td><td>Vector with the resulting path.</td></tr>
  </table>
  </dd>
</dl>
<p>Complexity O(V^2), V: number of vertices. </p><dl class="section return"><dt>Returns</dt><dd>The total distance of the path. </dd></dl>

</div>
</div>
<a id="a2a966c7db5e08c724bbf39ca6ba9bdc1" name="a2a966c7db5e08c724bbf39ca6ba9bdc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a966c7db5e08c724bbf39ca6ba9bdc1">&#9670;&#160;</a></span>twoOpt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Menu::twoOpt </td>
          <td>(</td>
          <td class="paramtype">Graph&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>minPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>minDist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Improves the path using the 2-opt algorithm. This function applies the 2-opt algorithm to optimize the given path. It swaps pairs of edges to find a shorter path until there is no improvement possible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Pointer to the graph. </td></tr>
    <tr><td class="paramname">minPath</td><td>Reference to the vector with the minimum path. </td></tr>
    <tr><td class="paramname">minDist</td><td>Reference to the minimum distance of the path. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_menu_8h_source.html">Menu.h</a></li>
<li><b>Menu.cpp</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
